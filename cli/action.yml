name: "Slack: Run CLI Command"
author: "slackapi"
description: "Install the Slack CLI and run a command in a GitHub Actions workflow"
inputs:
  command:
    description: "A Slack CLI command to run without the 'slack' prefix."
    required: true
  token:
    description: "A service token passed as the '--token' flag to the CLI command."
    required: false
  version:
    description: "The version of the Slack CLI to install. Defaults to the latest."
    required: false
outputs:
  ok:
    description: "If the command completed with a '0' exit code."
    value: ${{ steps.slack-cli-unix.outputs.ok || steps.slack-cli-windows.outputs.ok }}
  response:
    description: "The standard output from the CLI command."
    value: ${{ steps.slack-cli-unix.outputs.response || steps.slack-cli-windows.outputs.response }}
  time:
    description: "The Unix epoch time that the step completed."
    value: ${{ steps.slack-cli-unix.outputs.time || steps.slack-cli-windows.outputs.time }}
runs:
  using: composite
  steps:
    - name: Check if Slack CLI already exists
      id: slack-cli-check
      shell: bash
      run: |
        if command -v slack &> /dev/null; then
          echo "cli-exists=true" >> "$GITHUB_OUTPUT"
        else
          echo "cli-exists=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Cache Slack CLI
      if: steps.slack-cli-check.outputs.cli-exists != 'true'
      id: cache-cli
      uses: actions/cache@0400d5f644dc74513175e3cd8d07132dd4860809 # v4.2.4
      with:
        path: |
          ${{ runner.os == 'Windows' && format('{0}\AppData\Local\slack-cli', env.USERPROFILE) || format('{0}/.slack/bin', env.HOME) }}
        key: slack-cli-${{ runner.os }}-${{ runner.arch }}-${{ inputs.version }}

    - name: Add Slack CLI to PATH (Linux/macOS)
      if: steps.slack-cli-check.outputs.cli-exists != 'true' && runner.os != 'Windows'
      shell: bash
      run: echo "$HOME/.slack/bin" >> "$GITHUB_PATH" # zizmor: ignore[github-env]

    - name: Add Slack CLI to PATH (Windows)
      if: steps.slack-cli-check.outputs.cli-exists != 'true' && runner.os == 'Windows'
      shell: pwsh
      run: Add-Content -Path $env:GITHUB_PATH -Value "$env:USERPROFILE\AppData\Local\slack-cli\bin" # zizmor: ignore[github-env]

    - name: Install Slack CLI (Linux/macOS)
      if: >-
        steps.slack-cli-check.outputs.cli-exists != 'true' &&
        steps.cache-cli.outputs.cache-hit != 'true' &&
        runner.os != 'Windows'
      shell: bash
      run: |
        if [ -n "$SLACK_CLI_VERSION" ]; then
          curl -fsSL https://downloads.slack-edge.com/slack-cli/install.sh | bash -s -- -v "$SLACK_CLI_VERSION"
        else
          curl -fsSL https://downloads.slack-edge.com/slack-cli/install.sh | bash -s
        fi
      env:
        SLACK_CLI_VERSION: ${{ inputs.version }}

    - name: Install Slack CLI (Windows)
      if: >-
        steps.slack-cli-check.outputs.cli-exists != 'true' &&
        steps.cache-cli.outputs.cache-hit != 'true' &&
        runner.os == 'Windows'
      shell: pwsh
      run: |
        if ($env:SLACK_CLI_VERSION) {
          $installer = Join-Path $env:TEMP "install-slack-cli.ps1"
          Invoke-WebRequest -Uri "https://downloads.slack-edge.com/slack-cli/install-windows-dev.ps1" -OutFile $installer
          & $installer -v $env:SLACK_CLI_VERSION
        } else {
          irm https://downloads.slack-edge.com/slack-cli/install-windows-dev.ps1 | iex
        }
      env:
        SLACK_CLI_VERSION: ${{ inputs.version }}

    - name: Run Slack CLI command (Linux/macOS)
      if: runner.os != 'Windows'
      id: slack-cli-unix
      shell: bash
      env:
        SLACK_COMMAND: ${{ inputs.command }}
        SLACK_TOKEN: ${{ inputs.token }}
      run: |
        args="$SLACK_COMMAND --skip-update"
        if [ -n "$SLACK_TOKEN" ]; then
          args="$args --token $SLACK_TOKEN"
        fi

        set +e
        output=$(slack $args 2>&1 | tee /dev/stderr)
        exit_code=$?
        set -e

        echo "$output"

        echo "ok=$([ $exit_code -eq 0 ] && echo 'true' || echo 'false')" >> "$GITHUB_OUTPUT"
        echo "time=$(date +%s)" >> "$GITHUB_OUTPUT"

        echo "response<<SLACKCLIEOF" >> "$GITHUB_OUTPUT"
        echo "$output" >> "$GITHUB_OUTPUT"
        echo "SLACKCLIEOF" >> "$GITHUB_OUTPUT"

        if [ $exit_code -ne 0 ]; then
          echo "::error::Slack CLI command failed with exit code $exit_code"
          exit $exit_code
        fi

    - name: Run Slack CLI command (Windows)
      if: runner.os == 'Windows'
      id: slack-cli-windows
      shell: pwsh
      env:
        SLACK_COMMAND: ${{ inputs.command }}
        SLACK_TOKEN: ${{ inputs.token }}
      run: |
        Write-Output "DEBUG: PATH entries:"
        $env:PATH -split ';' | Where-Object { $_ -match 'slack' } | ForEach-Object { Write-Output "  $_" }
        Write-Output "DEBUG: Looking for slack binary..."
        Get-Command slack -ErrorAction SilentlyContinue | Format-List
        $slackDir = "$env:USERPROFILE\AppData\Local\slack-cli\bin"
        Write-Output "DEBUG: Contents of ${slackDir}:"
        if (Test-Path $slackDir) { Get-ChildItem $slackDir } else { Write-Output "  Directory not found!" }

        # Pre-create all .slack filesystem structures to eliminate lazy creation as a suspect
        $slackConfigDir = "$env:USERPROFILE\.slack"
        if (-not (Test-Path $slackConfigDir)) { New-Item -ItemType Directory -Path $slackConfigDir -Force | Out-Null }

        $credsPath = "$slackConfigDir\credentials.json"
        if (-not (Test-Path $credsPath)) { Set-Content -Path $credsPath -Value "{}`n" }

        $configPath = "$slackConfigDir\config.json"
        if (-not (Test-Path $configPath)) { Set-Content -Path $configPath -Value "{}`n" }

        $logsDir = "$slackConfigDir\logs"
        if (-not (Test-Path $logsDir)) { New-Item -ItemType Directory -Path $logsDir -Force | Out-Null }

        $configSubDir = "$slackConfigDir\config"
        if (-not (Test-Path $configSubDir)) { New-Item -ItemType Directory -Path $configSubDir -Force | Out-Null }

        # Permission diagnostics
        Write-Output "DEBUG: .slack directory contents:"
        Get-ChildItem -Path $slackConfigDir -Recurse | ForEach-Object { Write-Output "  $($_.FullName) [$(if($_.PSIsContainer){'dir'}else{$_.Length.ToString() + 'b'})]" }

        Write-Output "DEBUG: Testing file read/write access..."
        try {
          $content = Get-Content $credsPath -Raw
          Write-Output "  credentials.json readable: '$content'"
        } catch {
          Write-Output "  ERROR reading credentials.json: $_"
        }

        try {
          $testFile = "$slackConfigDir\test-write.tmp"
          Set-Content -Path $testFile -Value "test"
          Remove-Item $testFile
          Write-Output "  .slack directory writable: OK"
        } catch {
          Write-Output "  ERROR writing to .slack directory: $_"
        }

        $cliArgs = "$env:SLACK_COMMAND --skip-update"
        if ($env:SLACK_TOKEN) {
          $cliArgs = "$cliArgs --token $env:SLACK_TOKEN"
        }

        $slackExe = (Get-Command slack).Source
        Write-Output "DEBUG: Starting at $(Get-Date -Format 'HH:mm:ss.fff'): $slackExe $cliArgs"

        # Use .NET Process API directly for reliable timeout + output capture
        $psi = [System.Diagnostics.ProcessStartInfo]::new($slackExe, $cliArgs)
        $psi.UseShellExecute = $false
        $psi.RedirectStandardOutput = $true
        $psi.RedirectStandardError = $true
        $psi.CreateNoWindow = $true

        $proc = [System.Diagnostics.Process]::new()
        $proc.StartInfo = $psi

        try {
          $proc.Start() | Out-Null
          Write-Output "DEBUG: Process started with PID $($proc.Id)"
        } catch {
          Write-Output "ERROR: Failed to start process: $_"
          Write-Output $_.ScriptStackTrace
          exit 1
        }

        # Read stdout/stderr asynchronously to avoid pipe buffer deadlock
        $stdoutTask = $proc.StandardOutput.ReadToEndAsync()
        $stderrTask = $proc.StandardError.ReadToEndAsync()

        $exited = $proc.WaitForExit(60000)  # 60 second timeout

        if (-not $exited) {
          Write-Output "ERROR: slack CLI hung for 60s, dumping diagnostics..."
          Write-Output "DEBUG: Process ID: $($proc.Id)"
          Write-Output "DEBUG: Process threads:"
          try {
            Get-Process -Id $proc.Id | Select-Object -ExpandProperty Threads | Format-Table Id, ThreadState, WaitReason -AutoSize
          } catch {
            Write-Output "  Could not get thread info: $_"
          }
          $proc.Kill()
          $proc.WaitForExit(5000)
          # After kill, async reads will complete with whatever was buffered
          [void]$stdoutTask.Wait(5000)
          [void]$stderrTask.Wait(5000)
          Write-Output "DEBUG: stdout captured:"
          Write-Output $stdoutTask.Result
          Write-Output "DEBUG: stderr captured:"
          Write-Output $stderrTask.Result
          $exit_code = 1
        } else {
          [void]$stdoutTask.Wait(5000)
          [void]$stderrTask.Wait(5000)
          $exit_code = $proc.ExitCode
          Write-Output "DEBUG: CLI completed at $(Get-Date -Format 'HH:mm:ss.fff') with exit code $exit_code"
          Write-Output $stdoutTask.Result
          if ($stderrTask.Result) { Write-Output "DEBUG: stderr: $($stderrTask.Result)" }
        }

        $output = if ($stdoutTask.IsCompleted) { $stdoutTask.Result } else { "" }

        "ok=$( if ($exit_code -eq 0) { 'true' } else { 'false' } )" >> $env:GITHUB_OUTPUT
        "time=$([DateTimeOffset]::UtcNow.ToUnixTimeSeconds())" >> $env:GITHUB_OUTPUT

        "response<<SLACKCLIEOF" >> $env:GITHUB_OUTPUT
        $output >> $env:GITHUB_OUTPUT
        "SLACKCLIEOF" >> $env:GITHUB_OUTPUT

        if ($exit_code -ne 0) {
          Write-Output "::error::Slack CLI command failed with exit code $exit_code"
          exit $exit_code
        }
